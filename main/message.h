/* 
 * File:   message.h
 * Author: dgs
 * 
 * 
 * This file is common to both client and server.
 * 
 * 5-19-18 Changed GT_Targets to GT_TargetAdventure, added GT_TargetChallenge.
 * 
 * 5-11d-18 Added MSGTYPE_HIT For C->S Data[1] = DataByte.
 * 
 * 5-11c-18 Added ReloadStation, MSGTYPE_RELOAD.
 * 
 * 5-11b-18 Removed GameParms::ShotsLeft, replaced with GameParms::ShotsInit.
 * 
 * 5-10-18 Removed GT_Timed. 
 * 
 * 5-10-18
 *    Added CClientStats::ShotsLeft.
 * 
 * 5-9g-18 Added CGameParms::ShotsLeft, PreGameDelaySec, NumberOfTargets.
 * 
 * 5-7-18 Added Priority to MSGTYPE_SAY_PHRASE messages.
 * 
 * 5-2-18b Added AnnounceLeaderTimeSecInit.
 * 
 * 4-30-18 Added MSGTYPE_HINT, CGameParms::Locate.
 * 
 * 4-26-18 
 * 
 * 4-24b-18 Added CTarget.
 * 
 * 4-23-18b Added MSGTYPE_GAME_START_STOP.
 * 
 * 4-21-18c Moved TargetList to CGameParms so that the gun has a copy of the targets in case
 *    it goes offline.
 * hi
 * 4-19-18 Added GT_Targets, TargetList.
 * 
 * 4-17c-18
 * 
 * 4-3-18b 
 * 
 * 3-13-18 Target changes.
 * 
 * 3-10-18 Added ClientType, MSGTYPE_TARGET_COMMAND.
 * 
 * 2-18-18
 * 
 * 2-17-18 Added LivesLeft, changed WeWereHitTime10Ms to StunTime10Ms.
 * 
 * 1-5-18 ClientStats.ClearActivityTime()
 * 
 * 1-2-18b Move StunTime10Ms to a common param.
 *    Added ShotsLeft.
 * 
 * 1-1-18 Added LoudnessSounds, LoudnessWords, MSGTYPE_ANNOUNCE_REM_TIME.
 *    Removed CPowerUps. Power-Ups are now just Game Parameters.
 *    Added CGameParms::SaveToFile(), ReadFromFile().
 * 
 * 12-23-17 Added Game Time.
 * 
 * 12-14-17 Added TestMode.
 * 
 * 10-31-17
 * 
 * 10-23-17 Separated GameParmsCommon and GameParms.
 *    Added full paths to files.
 * 
 * 9-7-17 Added CGameParms::IRPowerMode, CClientStats::InactivityTimerSec.
 */

#ifndef MESSAGE_H
#define	MESSAGE_H

#include "common.h"

// These files are used ONLY on the svr:
#define GAMEPARMS_FN "/usr/RpiSvr/www/gameparms.dat"
#define GAMEPARMS_MASTER_FN "/usr/RpiSvr/www/gameparms1"

// These files are used ONLY on the client:
#define NAME_FN "/usr/RpiClient/name.txt"

// Initial game time.
#define DEFAULT_GAME_TIME_SEC 60*10

// This is the number of seconds before the system shuts-down.
#define ACTIVITY_TIME_SEC 60*20

// The game starts this number of second after the Start Game button is pressed.
#define DEFAULT_PRE_GAME_SECONDS 15        

// Message Types

enum e_MsgType {
    MSGTYPE_HIT = 1,            //    I've been hit (C->S) or you hit someone (S->C)
    //       Data[0] = ShooterIP
    //       For S->C Data[1] = ClientType (0=gun, 1=target)
    //       For C->S Data[1] = DataByte
    MSGTYPE_GAME_PARMS,         //    Game over (S->C)
    //       Data[..] = CGameParms
    MSGTYPE_FD,                 //    Here is your file descriptor (S->C).
    MSGTYPE_CID,                //    Here is my client ID (C->S).
    MSGTYPE_STATUS,             //    Give me your stats (S->C) or here are my stats (C->S)
    //       Data[..] = CClientStats
    MSGTYPE_PROGRAM_UPDATE,     //   Tell the client to update the program.
    MSGTYPE_POWEROFF,           // Power-off the gun
    MSGTYPE_SAY_PHRASE,         // Say a phrase (S->C)
    //       Data[0] = Priority (0=low, 1=high)
    //       Data[..] = varying length text
    MSGTYPE_TARGET_COMMAND,     // This is a command to the target
    //       Data[0] = sub-command (see e_TargCmdType)
    MSGTYPE_GAME_START_STOP,    // The game has started or stopped.
    //       Data[0] = Game Progress command (e_GameProgressCmd)
    MSGTYPE_HINT,               // In a Targets game, request a hint (C->S)
    MSGTYPE_RELOAD              // Reload with the given number of shots.
    //       Data[0] = Shots to reload.
};

enum e_GameProgress {
   E_GP_GAME_ABOUT_TO_START = 0,
   E_GP_GAME_START,
   E_GP_GAME_STOP
};

// These are MSGTYPE_TARGET_COMMAND sub-commands
enum e_TargCmdType {
    TGTCMDTYPE_START_WATCHING = 1,
    TGTCMDTYPE_STOP_WATCHING,
    TGTCMDTYPE_BEEP,
    TGTCMDTYPE_BLINK,
    TGTCMDTYPE_SETCOLOR
};


typedef enum {
	BLINK_OFF = 0, ON_OFF, ROTATE_CW, ROTATE_CCW, FADE
} E_BLINKTYPE;

typedef struct {
   enum e_TargCmdType TargCmd;
   int ListenTime; // seconds (0=forever)
   int Color;
   int OnPeriod;   // hz
   int OffPeriod;
   int Duration;   // ms
   int BeepPitch;
   int Count;      // -1 = forever
   E_BLINKTYPE BlinkType; 
} STargetSubCmd;



// Client Statistics
// These values are generated by the client.
//
class CClientStats {
public:
   // This is the number of shots that were successful.
   // This value may not be accurate. It is stored on the svr and synced from S->C periodically.
   int SuccessfulShots;
   int ShotsFired;
   // This is the number of hit accumulated since we were killed (not used unless HitsToKill > 1).
   int HitsThisKill;
   // Number of lives left (when playing Elimination),  -1 = unlimited
   int LivesLeft;
   // Number of shots left, -1 = unlimited
   int ShotsLeft;
   // Number of times we were hit since start of game (used for ranking).
   int WeWereHitTotal;
   // /This is the last IP that this client killed.
   int LastClientHitIP;
   // Battery voltage
   int BatteryVoltage;
   // Battery level
   int BatteryLevelPercent;
   // Wireless signal quality
   int WirelessQuality;
   // This is the time since the last activity (trigger pull, etc.) It is used for the auto-shutdown.
   int InactivityTimerSec;
   // Version
   int Version;
   // Client name
   char Name[20];
   // Client Type (0 = Gun, 1 = Target)
   char ClientType;
public:

   CClientStats() {
      SuccessfulShots = 0;
      ShotsFired = 0;
      LivesLeft = 0;
      ShotsLeft = -1;
      HitsThisKill = 0;
      WeWereHitTotal = 0;
      WirelessQuality = 0;
      BatteryVoltage = 0;
      BatteryLevelPercent = 0;
      LastClientHitIP = 0;
      ClientType = 0; // Gun
      InactivityTimerSec = ACTIVITY_TIME_SEC;
      strcpy(Name, "null");
#ifdef VERSION_NUM        
      Version = VERSION_NUM;
#endif        
   }

   void ClearActivityTime() { InactivityTimerSec = ACTIVITY_TIME_SEC; }
   
   /**
    * Read the client's name from disk.
    */
   void ReadName(void) {
      FILE *f = fopen(NAME_FN, "r");

      if (!f) {
         return;
      }

      fread(Name, 1, 20, f);
      fclose(f);
   }

   char *GetStr(char *s) {
      sprintf(s, "SuccessfulShots:%u\n"
              "ShotsFired:%u\n"
              "HitsThisKill:%u\n"
              "LivesLeft:%u\n"
              "ShotsLeft:%u\n"
              "WeWereHitTotal:%u\n"
              "WirelessQuality:%u\n"
              "BatteryVoltage:%u\n"
              "BatteryLevelPercent:%u\n"
              "InactivityTimerSec:%u\n"
              "Name:%s\n"
              "Version:%u\n"
              "ClientType:%u\n",
              SuccessfulShots, ShotsFired, HitsThisKill, LivesLeft,ShotsLeft,
              WeWereHitTotal, WirelessQuality, BatteryVoltage, BatteryLevelPercent, InactivityTimerSec, Name, Version,
              ClientType);
      return s;
   }

   char *GetJsonStr(char *s) {
      sprintf(s, "\"SuccessfulShots\":%u,"
              "\"ShotsFired\":%u,"
              "\"HitsThisKill\":%u,"
              "\"LivesLeft\":%u,"
              "\"ShotsLeft\":%u,"
              "\"WeWereHitTotal\":%u,"
              "\"WirelessQuality\":%u,"
              "\"BatteryVoltage\":%u,"
              "\"BatteryLevelPercent\":%u,"
              "\"InactivityTimerSec\":%u,"
              "\"LastClientHitIP\":%u,"
              "\"Name\":\"%s\","
              "\"Version\":%u,"
              "\"ClientType\":%u",
              SuccessfulShots, ShotsFired, HitsThisKill, LivesLeft,ShotsLeft,
              WeWereHitTotal, WirelessQuality, BatteryVoltage, BatteryLevelPercent, InactivityTimerSec,
              LastClientHitIP, Name, Version, ClientType);
      return s;
   }
};

// IMPORTANT: if you change E_GAMETYPE then you must also modify HandleWebCommands() and 
//    common.js:StartStopGame().
//
enum E_GAMETYPE {
   // Win by eliminating all players
   GT_Elimination=0,
   // Win by hitting all the targets.
   GT_TargetAdventure,
   // Win by hitting more targets than the other players.
   GT_TargetChallenge
};

#define MAX_TARGETS 15

class CTarget {
public:
   int IP;
   int Num;
   
public:
   CTarget &operator=(CTarget &t) {
      this->IP = t.IP;
      this->Num = t.Num;
      
      return *this;
   }
};

// This is the list of targets that must be hit during a target game.
// If a target is hit then it is set to 0.
class CTargetList {
public:
   // List of target numbers.
   CTarget Targets[MAX_TARGETS];
   int Count;
   int CurrentTargeti;
public:
   CTargetList() { 
      Count = 0; 
      CurrentTargeti = 0;
      
      for (int i=0; i<MAX_TARGETS; i++)
         Targets[i].IP = Targets[i].Num = 0;
   }
   
   /**
    * Return the next target number or 0 if there are no more targets in the list.
    * @return 
    */
   int NextTargetNum() {
     CurrentTargeti++;
     if (CurrentTargeti >= Count) {
        CurrentTargeti--;
        return 0;
     }
     else 
        return Targets[CurrentTargeti].Num;
   }
   
   void Add(int num, int ip) {
      if (Count < MAX_TARGETS) {
         Targets[Count].Num = num;
         Targets[Count].IP = ip;
         Count++;
      }
   }
   
   void Print() {
      printf("TARGETS:\n");
      printf("Count = %u, CurrentTargeti = %u\n",Count,CurrentTargeti);
      for (int i=0; i<Count; i++) {
          printf("IP=%u Num=%u\n",Targets[i].IP,Targets[i].Num);
      }
      printf("\n");FLUSH;
   }
   
   int CurrentTargetIP() { return Targets[CurrentTargeti].IP; }
   int CurrentTargetNum() { return Targets[CurrentTargeti].Num; }
   int TargetsLeft() { return Count - CurrentTargeti; }
   
   int TargetNumberFromIP(int IP) {
      for (int i=0; i<Count; i++) {
         if (Targets[i].IP == IP)
            return Targets[i].Num;
      }
      return 0;
   }
  
   void Randomize() {
      if (Count <= 0)
         return;
           
      int i0, i1;
      CTarget temp;
      for (int i=0; i<Count*100; i++) {
         i0 = rand() % Count;
         i1 = rand() % Count;
         temp = Targets[i0];
         Targets[i0] = Targets[i1];
         Targets[i1] = temp;
      }
   }
};

// Client Game Parameters
// These values indicate how the game is to be played. 
// They are changed by the svr.
// IMPORTANT: THESE PARMS MAY BE OVERWRITTEN BY THE SVR AT ANY TIME!

class CGameParms {
public:
   // COMMON GAME PARAMETERS
   // This is the basic game type: timed, first to a goal, etc.
   E_GAMETYPE GameType;
   // This is the time until the end of the game.
   int GameRemainingSec;
   // This is the total (initial) game time.
   int GameTimeSec;
   // This is the time that a client is idle after being hit.
   int StunTime10Ms;
   // Initial number of lives (when playing Elimination).
   int LivesInit;
   // This is the initial number of shots.
   int ShotsInit;
   // This is the test mode.
   // 0 = no test
   // 1 = Client can fire and be hit without game running.
   int TestMode;
   // Loudness Levels (%)
   int LoudnessSounds;
   int LoudnessWords;
   // This is the target list (only used for games that include targets).
   // This list indicates which targets must be hit during a game.
   // We are storing them in CGameParms to allow the gun to know which target to hit next in case it
   // goes offline.
   CTargetList TargetList;
   // Allows the number of targets to be set. If 0 then use all targets. If greater than
   //  number of physical targets then re-use targets.
   int NumberOfTargets;
   
   // This is the time between announcing the current leader(s). 0=never announce
   int AncLeaderTimeSec;
   // Time before the game starts.
   int PreGameDelaySec;

   // UNIQUE GAME PARAMETERS
   // This is the number of successive hits required for us to be killed. It can be
   // used to handicap a younger player.
   int HitsToKill;
   // Indicates the assigned team.
   // 0=n/c, 1=red, 2=green, 3=blue
   int Team;
   // IR Power: 1=high, 0=low
   // NOTE that the current (client) state is global IRPowerMode_Current.
   bool IRPowerMode;
   // This will cause the client to beep and/or blink to show location.
   bool Locate;
   // This target is a reloading station
   char ReloadStation; 
   // Power-ups
   int PwrUpRapidFire;
   int PwrUpStealth;
   int PwrUpBounceBack;

#ifndef ESPIDF   
public:
   // Write all class data to a JSON file. This is used for communication to the web server.

   int WriteJSONFile() {
      char s[1000];

      FILE* fd = fopen(GAMEPARMS_FN, "w+");

      if (fd == NULL)
         return 0;

      GetJsonStrCommon(s);
      fwrite(s, strlen(s), 1, fd);

      fclose(fd);

      return 1;
   }
   
   CGameParms() {
      HitsToKill = 1;
      Team = 0;
      StunTime10Ms = 0;
      IRPowerMode = 0;
      LivesInit = 1;
      GameTimeSec = DEFAULT_GAME_TIME_SEC;
      LoudnessSounds = 100;
      LoudnessWords = 100;
      PwrUpRapidFire = 0;
      PwrUpStealth = 0;
      PwrUpBounceBack = 0;
      Locate = 0;
      ReloadStation = 0;
      AncLeaderTimeSec = 180;
      ShotsInit = 0;
      PreGameDelaySec = DEFAULT_PRE_GAME_SECONDS;
      NumberOfTargets = 0;
      TestMode = 0;
   }

   
   /**
    * Read the class instance from a file.
    * This is used for restoring game parameters at power-up.
    * @return 
    */
   int ReadFromFile(char *filename) {
      printf("CGameParms::ReadFromFile\n");
      FLUSH;

      ifstream file(filename, std::ifstream::binary);
      if (!file.is_open())
         return 1;

      file.read((char*) &GameType, sizeof (GameType));
      file.read((char*) &GameRemainingSec, sizeof (GameRemainingSec));
      file.read((char*) &GameTimeSec, sizeof (GameTimeSec));
      file.read((char*) &HitsToKill, sizeof (HitsToKill));
      file.read((char*) &Team, sizeof (Team));
      file.read((char*) &IRPowerMode, sizeof (IRPowerMode));
      file.read((char*) &StunTime10Ms, sizeof (StunTime10Ms));
      file.read((char*) &PwrUpRapidFire, sizeof (PwrUpRapidFire));
      file.read((char*) &PwrUpStealth, sizeof (PwrUpStealth));
      file.read((char*) &PwrUpBounceBack, sizeof (PwrUpBounceBack));
      file.read((char*) &TestMode, sizeof (TestMode));
      file.read((char*) &LoudnessSounds, sizeof (LoudnessSounds));
      file.read((char*) &LoudnessWords, sizeof (LoudnessWords));
      file.read((char*) &LivesInit, sizeof (LivesInit));
      file.read((char*) &AncLeaderTimeSec, sizeof (AncLeaderTimeSec));
      file.read((char*) &ShotsInit, sizeof (ShotsInit));
      file.read((char*) &PreGameDelaySec, sizeof (PreGameDelaySec));
      file.read((char*) &NumberOfTargets, sizeof (NumberOfTargets));

      file.close();

      return 0;
   }


   /**
    *  Write the class data to a file.
    *  This is used for restoring game parameters at power-up.
    * 
    * @param ParamName
    * @param Value
    * @return 
    */
   int SaveToFile(char *filename) {
      printf("CGameParms::SaveToFile\n");
      FLUSH;

      ofstream file(filename, std::ifstream::binary);
      if (!file.is_open())
         return 1;

      file.write((char*) &GameType, sizeof (GameType));
      file.write((char*) &GameRemainingSec, sizeof (GameRemainingSec));
      file.write((char*) &GameTimeSec, sizeof (GameTimeSec));
      file.write((char*) &HitsToKill, sizeof (HitsToKill));
      file.write((char*) &Team, sizeof (Team));
      file.write((char*) &IRPowerMode, sizeof (IRPowerMode));
      file.write((char*) &StunTime10Ms, sizeof (StunTime10Ms));
      file.write((char*) &PwrUpRapidFire, sizeof (PwrUpRapidFire));
      file.write((char*) &PwrUpStealth, sizeof (PwrUpStealth));
      file.write((char*) &PwrUpBounceBack, sizeof (PwrUpBounceBack));
      file.write((char*) &TestMode, sizeof (TestMode));
      file.write((char*) &LoudnessSounds, sizeof (LoudnessSounds));
      file.write((char*) &LoudnessWords, sizeof (LoudnessWords));
      file.write((char*) &LivesInit, sizeof (LivesInit));
      file.write((char*) &AncLeaderTimeSec, sizeof (AncLeaderTimeSec));
      file.write((char*) &ShotsInit, sizeof (ShotsInit));
      file.write((char*) &PreGameDelaySec, sizeof (PreGameDelaySec));
      file.write((char*) &NumberOfTargets, sizeof (NumberOfTargets));

      file.close();

      return 0;
   }

   /**
    * Modify a game parameter and then save parms to disk. 
    * Note that not all parms are saved to disk.
    * 
    * @param ParamName
    * @param Value
    * @return 1 on success, 0 on error.
    */
   int Modify(string ParamName, int Value) {
      printf("CGameParms::Modify() '%s ->%u'\n", ParamName.c_str(), Value);
      FLUSH;

      if (ParamName == "PwrUpRapidFire")
         PwrUpRapidFire = Value;
      else if (ParamName == "PwrUpStealth")
         PwrUpStealth = Value;
      else if (ParamName == "PwrUpBounceBack")
         PwrUpBounceBack = Value;
      else if (ParamName == "HitsToKill")
         HitsToKill = Value;
      else if (ParamName == "Team")
         Team = Value > 3 ? 3 : 0;
      else if (ParamName == "IRPowerMode")
         IRPowerMode = Value > 0 ? 1 : 0;
      else if (ParamName == "ShotsInit")
         ShotsInit = Value;
      else if (ParamName == "TestMode")
         TestMode = Value;
      else if (ParamName == "StunTime10Ms")
         StunTime10Ms = Value;
      else if (ParamName == "LoudnessSounds")
         LoudnessSounds = Value;
      else if (ParamName == "LoudnessWords")
         LoudnessWords = Value;
      else if (ParamName == "LivesInit")
         LivesInit = Value;
      else if (ParamName == "Locate")
         Locate = Value;
      else if (ParamName == "GameTimeSec")
         // This value is given in seconds from the web svr so we need to convert.
         GameTimeSec = 60 * Value;
      else if (ParamName == "AncLeaderTimeSec")
         AncLeaderTimeSec = Value;
      else if (ParamName == "GameType")
         GameType = (E_GAMETYPE)Value;
      else if (ParamName == "PreGameDelaySec")
         PreGameDelaySec = Value;
      else if (ParamName == "NumberOfTargets")
         NumberOfTargets = Value;
      else if (ParamName == "ReloadStation")
         ReloadStation = Value;
      else {
         printf("CGameParms::Modify() ERROR: unknown ParamName '%s'\n", ParamName.c_str());
         FLUSH;
         return 0;
      }

      // Save the game parms to disk.
      SaveToFile((char*) GAMEPARMS_MASTER_FN);

      return 1;
   }

   // Get the JSON for only the unique parms.
   char *GetJsonStrUnique(char *s) {
      sprintf(s, "\"PwrUpRapidFire\":%u,"
              "\"PwrUpStealth\":%u,"
              "\"PwrUpBounceBack\":%u,"
              "\"HitsToKill\":%u,"
              "\"Team\":%u,"
              "\"IRPowerMode\":%u,"
              "\"TestMode\":%u,"
              "\"Locate\":%u,"
              "\"TargetsHit\":%u,"
              "\"ReloadStation\":%u",
              PwrUpRapidFire, PwrUpStealth, PwrUpBounceBack,
              HitsToKill, Team, IRPowerMode, TestMode,Locate,
              TargetList.CurrentTargeti,ReloadStation);
      return s;
   }

   // Get the JSON for only the common parms.
   char *GetJsonStrCommon(char *s) {
      sprintf(s,
              "{\"GameRemainingSec\":%u,"
              "\"GameTimeSec\":%u,"
              "\"LivesInit\":%u,"
              "\"ShotsInit\":%u,"
              "\"LoudnessSounds\":%u,"
              "\"LoudnessWords\":%u,"
              "\"GameType\":%u,"
              "\"PreGameDelaySec\":%u,"
              "\"AncLeaderTimeSec\":%u,"
              "\"NumberOfTargets\":%u,"
              "\"StunTime10Ms\":%u}",
              GameRemainingSec, GameTimeSec, LivesInit, ShotsInit, LoudnessSounds, 
              LoudnessWords, GameType, PreGameDelaySec, AncLeaderTimeSec, NumberOfTargets, StunTime10Ms);
      return s;
   }
#endif //ESPIDF
};

class CMsg {
public:
   // Message type
   e_MsgType Type;

   // Socket descriptor
   int FD;
   // Data (optional)
   char Data[300];
   // Checksum
   //int Checksum;
public:

   CMsg(void) {
      FD = 0;
   }
};

#endif	/* MESSAGE_H */

