/*
 * Temperature Logger by Doug Sisco
 * 
 * The Temperature Logger records the temperature read from a Maxim 31856 Thermocouple IC and
 *		creates a line graph viewable as a web page.
 * 
 * NEXT
 *    BUG: The SonicWall drops http packets:
Ethernet Header
Ether Type: IP(0x800), Src=[30:ae:a4:0c:ea:c0], Dst=[18:b1:69:ef:b2:a8]
IP Packet Header
IP Type: TCP(0x6), Src=[192.168.1.87], Dst=[192.185.123.20]
TCP Packet Header
TCP Flags = [ACK,PSH,], Src=[64060], Dst=[80], Checksum=0x920f
Application Header
HTTP
Value:[0]
DROPPED, Drop Code: 105(Enforced Content Filter Policy), Module Id: 65(CFS), (Ref.Id: _7155_uyHtJcpfngKrRmv) 1:2)

*    Http return code should be examined and the LED turned RED if bad.
 *    LED should be yellow when first powered on and no internet connection.
 *    
 *    Current values: include time of this value since, if it is old it will NOT show in the chart.
 *		Also may be a warning that the value is not current.
 *    Startup: currently the web server is blocked until the date is set.
 *        The date should be set to 1970 (or an old date) and then updated when the time svr is contacted.
 *    Need unit testing.
 *    Check that all config settings are within range: I found that one of the axis settings was out of range but was
 *       saved as part of the config.
 *    Select temperatures to include in title (tab).
 *    Setting to enable/disable slope.
 *    Setting to select channel for title.
 *    Zoom should be function of browser, not the same on all browsers.
 *    Arrows in tab and in status pane to show temperature trends.
 *    In main.htm, update values that are invalid with blanks.
 *		WHAT IS CHARTSAMPLES??
 *    Add channel names.
 *		Setting to enable channel on chart.
 *		If ajax does not respond within x seconds, show warning
 *    If last N readings were in error then report.
 *		Signal strength, battery level.
 *		Bluetooth interface (for IP address, etc.)
 *		Label each channel
 *		Assign each channel to a slot.
 *		Assign each channel color.
 *		Warning email when channel temp reaches a high or low value.
 * 
 *		Bluetooth interface (for IP address, etc.)
 * 
 *		Press a push button to enable web server for 10 minutes (make this an option).
 * 
 * 
 *		Show statistics: number of data points, current value.
 * 
 *		Use localized graph js.
 *  * 
 *		Download values as csv file.
 * 
 * 
 *		Add multiple temperature inputs.
 * 
 * DEBUGGER
 *    2-13-20 To use the debugger perform the following steps:
 *      Set the DEBUGGER switch to 1.
 *      Program using the serial port.
 *      If debugger still doesn't work, unplug and re-plug the Olimex device. Then disconnect and reconnect the Olimex device
 *         to the VM. Check that the color LED resistor is 1K or higher.
 *      If that doesn't work then throw the entire board off the deck and scream as loud as possible.
 *      Added C18b20::InvalidReadsTotal.
 * 
 * MAINTENANCE
 *    +-------- Major revisions - Major bug fixes or changes which affect functionality or interface
 *    | +------ Minor revisions - Minor bug fixes
 *    | | +---- Cosmetic or revisions - All other changes
 *    X.X.X 
 *
 *    4-25-21 4.11 Added C18b20::ds18b20_init() so that the config register is set for 9-bit precision, though this may only be called on power-up.
 *      Also, I determined that the 18B20P (parasitic-only) device will not work above 120F. These devices are marked with a 'P'.
 *      
 *      There is definately a problem reading temperatures higher than 180F/82C over a 6ft cable, even with 5V-powered devices.
 *      Devices connected directly to the board work up to 220F/105C (lower than the datasheet value of 257F/125C).
 *      
 *         To investigate the problem I tried
 *            - confirming with an ammeter that the devices are drawing power from the 5V line (I measured 0.7mA at intervals of about 1hz).
 *            - slowing the conversion rate to 1/5 the normal rate.
 *            - inserting a 470 resistor in series with data line at both ends.
 *            - using only a three wire bus (instead of an ethernet cable with all 8 wires, 5 unused).
 *            - powering from 3.3V instead of 5V
 *
 *    5-15-20 4.10.0 Same for SendHttpRequestErrorsCount. Also re-added log for socket errors. I really want to see these
 *      errors but I don't want the reboot unless they occur multiple times.
 *    5-14-20 4.9.0 Changed socket error reporting so that a number of consecutive errors must occur before the error
 *      is reported.
 *    4-28-20 4.8.0 Added error log string argument to CStatusLED::Set(), added log detail to all errors.
 *      Warning is no longer issued on startup, the led is just changed to yellow.
 *    4-27-20 4.6.2 Fixed led colors and web post blinking.
 *    4-25-20 4.5.0 Shortened delay between samples from 500 to 100.
 *       Changed led to 'warning' during firmware upgrade.
 *    4-23-20 4.3.4 Fixed problem where 18B20 errors were occurring frequently on some sensors. 
 *       Added portENTER_CRITICAL(&mutex) calls to several functions in the DS18B20 driver.
 *       Added PauseTemperatureThread flag to prevent problems with the firmware upgrade feature.
 *       NOTE that this definitely fixed the 18B20 errors as there were almost no errors on any of the five 
 *          test devices.
 *
 *    4-22-20 4.2.1 Added logging of 18b20 sensor errors.
 *
 *    4-22-20 4.1.2 Fixed reboot time: was 18000 sec now 600 sec (10 min).
 *
 *    4-11-20 4.11 Error state changes are now logged. 
 *      Cancellation of reboot on system error is now logged.
 *
 *    4-11-20 4.9 Added Identify feature. 
 *
 *    4-11-20 4.8 Added remote reset capability.
 *
 *    4-10-20 4.7 Added logging of channel ONLINE/OFFLINE status messages. 
 *
 *    4-9-20 Changed the TC temperature read functions to use the built-in MAX31856 open-circuit detection.
 *      Also determined that the MAX31856 MUX design is sound and accurate for K-type thermocouples but 
 *      is not accurate above 1000F.
 *
 *    4-8-20 Researched new driver for MAX31856 to fix the problem where tc readings are about 5F too high.
 *      After some testing I found that the problem is the thermocouple wire, not the MAX31856.
 *      Also, high temperature measurements are accurate.
 *      I also researched whether a new driver would allow for faster temperature readings. I (re-)discovered that 
 *          the MAX31856 datasheet indicates that measurements take a minimum of 160ms.
 *
 *    3-29-20 4.0 Added Over-The-Air (OTA) program updates (see Design Notes, below).
 *      Added EventLog (see Design Notes, below). 
 *
 *    2-13-20 Confirmed that the time is synchronized every hour. I did this by setting SW1 to change the time and then waiting 
 *      for the time to be set correctly.
 *      
 *    Also found a fix to the problem that starting a serial connection using Putty causes a reboot: pins 1 or 2 of the serial
 *       connector (PREN or D0) are enabled when Putty is started.  I made a connector that breaks these connections, and this fixes
 *       the problem but of course prevents programming through the serial port.
 *
 *    2-13-20 Pushbutton switches: attempted to create an interrupt for the switches but after many hours
 *      concluded that the gpio interrupts are buggy in this ESP-IDF release. One guy on a forum said he finally
 *      gave up on getting interrupts to work. I found that the interrupts work but that they trigger intermittently
 *      regardless of the mode (neg or pos edge). I finally decided to simply poll the switches at 10hz.
 *
 *    2-11-20 2.1.1 Updated to ESP/IDF release v3.3 (was 3.2.2).
 *
 *    2-10-20 2.1 System reboots if a WIFI error persists for 10 minutes.
 *
 *    11-15-19 To enhance detection of good thermocouple temperature readings I added TC_LOW_MAX test in Thread_ReadTemperature().
 *    Changed constant values of min and max TC values to TC_HIGH_MAX and TC_LOW_MAX.
 *  
 *    11-13-19 In Thread_SendDataToSvr() removed LoopCount and added uptime.
 *    Configured new 'effort_pi' network.
 *    Changed WEB_URL to 'post_data.php'.
 *
 *    10-20-19 We now check for the svr response: server errors are now detected and the LED is changed accordingly.
 *    Note that if the SQL database cannot be contacted at all then an error is only reported in OpenSocket() at a timeout
 *       which takes about 30 seconds.
 *    Also note that this functionality cannot be tested by suspending the svr account because suspension does not disable the SQL server.
 *
 *    10-5-19 Removed code to read and write Config to flash. Eventually we may want to save the webserver address to flash.
 *    Removed hostname from config.
 *
 *    9-5-19 Added MCP2317 with I2C interface.
 *    Changed TC MUX address pins to MCP2317 outputs.
 *    Added channel LEDs to MCP2317 output.
 *    Changed tri-color LED pins to debugger pins.
 *    Changed triac output to MCP2317 output.
 *
 *    8-30-19 Changed MAX31856 SPI to use alternate pins so that it doesn't interfere with debugger connection.
 *
 *    8-29-19 Thermocouple open-sensor errors are now detected and reported as INVALID_TEMPERATURE.
 *    Confirmed that MAX31856 library uses the standard spi_master.c SPI library.
 *    
 *    Found that MAX31856 takes 143ms to take a measurement, and thus the 250ms delay in max31856_oneshot_temperature() is warranted.
 *    
 *    Found that unconnected TC channels were "bleeding" to the next adjacent channel because the 74HC4051 was holding the charge. 
 *       To fix this I added a 1M resistor across the MAX31856 sensor input. It does not seem to interfere with readings but it fixes the 
 *       "bleeding" problem. 
 *       We may also need protection devices from each input to ground to prevent static damage.
 *       
 *    Tested TC inputs for accuracy at 32F and range from -28F to 1000F.
 *
 *	  8-25-19 In appmain(), changed the priority of the Thread_ReadTemperature thread to maximum. This significantly reduces the number of DS18B20 read errors
 *		from 6% to .5%. 
 *	  Changed Thread_ReadTemperature() so that when a sensor read error occurs, the last good value is stored in the data point. In the last version
 *		a null value was stored.
 *	  Confirmed the timing of DS18B20 reads in ds18b20.cpp.
 *	  Added CChannel::Connected (at least one valid read has occurred).
 *
 *	  8-11-19 Attempted setting the current time from the GET response but there doesn't seem to be
 *	     an easy way to do this. It appears that the time is always synced to the NTP using an open socket,
 *	     though I could not confirm this.
 *
 *    6-19-19 Fixed memory leak in server/common.js/UpdateData(). 
 *
 *    6-18-19 Found that if a channel is not updating we will still see a current value but
 *       the chart line will not appear. This is because the chart only shows current values.
 *
 *    6-17-19 Moved project to local drive (j:) because phpStorm doees not play well with mapped drives: some of the files simply 
 *       would not sync from phpStorm to the NAS folder.
 *
 *    6-16-19 Completed printing current values on charts using additional SQL query.
 *    Fixed problem where chart updates would halt. This was due to occasional errors in the JSON returned 
 *       to the JS script: these errors were not handled so the script would simply quit. I added an error
 *       handler which simply calls another
 *
 *	  6-15-19 ESP-IDF V3.3 
 *	     Disabled html server.
 *	     Bug: crash after about 5 hours:
 *       -assertion "Operating mode must not be set while SNTP client is running" failed: file "C:/SysGCC/esp32/esp-idf/v3.3/components/lwip/lwip/src/apps/sntp/sntp.c", line 600, function: sntp_setoperatingmode abort() was called at PC 0x400d4243 on core 0
 *       This was due to the thread Thread_UpdateTime() which was created on 5-3-19.
 *       Removed all ESP-IDF informational statements by phy_printf(const char* format, ...) with an empty function in components/esp32/lib_printf.c to solve your problem.
 *
 *    5-3-19 Time is updated once per hour. 
 *
 *    2-15-19 Added Sensor Type menu to settings panel.
 *			Added slope calculation.
 * 
 *    2-13-19 Added TC selector, removed thermocouple_task() and moved it to Thread_ReadTemperature().
 * 
 *    2.10 Fixed thermocouple sign problem in max31856.c/thermocouple_read_temperature().
 * 
 *    2.9 Added Config::CheckValues().
 *        Increased accuracy of 18b20 sensors in ds18b20_get_temp().
 * 
 *    2.8 Initial update does not print invalid values on left.
 *			 Bigger buttons.
 *        After MAX_SUCCESSIVE_INVALID_READS successive temp reads the value is recorded as INVALID_TEMP (instead of being ignored).
 *        Chart now reflects the same colors as the left panel. 
 *           In ProcessChartRequest() added 'null' entries for invalid values instead of simply skipping the values in the chart data.
 *    2.7 Changed X-axis date format.
 * 
 * 
 * DESIGN NOTES
 * 
 * NETWORK DISCOVERY WAP
 *   IP is set in tcpip_adapter_lwip.c/tcpip_adapter_init().
 *   
 *   See https://www.freertos.org/FreeRTOS_Support_Forum_Archive/December_2017/freertos_Receive_muliple_packages_ff35b821j.html
 *   
 * OTA
 *      3-29-20 OTA uses the simple non-SSL example in C:\SysGCC\esp32\esp-idf\v3.3\examples\system\ota\simple_ota_example.
 *          This code had a few problems and I had to modifiy some library code to make it work properly.
 *          FIRMWARE_UPGRADE_PORT is defined in C:\SysGCC\esp32\esp-idf\v3.3\components\esp_http_client\esp_http_client.c
 *          I had to hard code this because it overrides the URL port nor the client port.
 *          See also the change to C:\SysGCC\esp32\esp-idf\v3.3\components\esp_https_ota\src\esp_https_ota.c to prevent an infinite loop in the case of a bad URL.
 *          
 *          OTA has it's own task loop which checks the flag FirmwareUpgradeInProcess once per second. It retreives the bin file, flashes it
 *          and then reboots.
 *          OTA is initiated by setting the SQL table var deviceflags bit 1. This flag is read with every data POST and is then reset during the next POST.
 *
 *      To use the Olimex debugger the tricolor led 100 ohm resistor must be removed. 
 *      ALSO, you must first set DEBUGGER compiler directive in tc_common.h and flash using the serial port.
 *      You might be able to flash using the debugger but it's easier to use the serial port first.
 *
 *      The MCP23S17 driver code is from  https://esp32.com/viewtopic.php?t=9309
 *
  *		The MAX31856 driver code is from https://github.com/djkilgore/max31856.
 * 
 * Unusable: 6,7,8,9,10,11 (connected internally)
 * Inputs-only: 34,35,36,39
 *   12 is also unusable as an input on startup. * 
 * 
 * TOOLCHAIN NOTES
 * 
 * To send messages to error.txt, use make flash monitor &> error.txt
 * 
 * 3-28-20 For OTA, in VisualGDB Project Properties, ESP-IDF Configuration, Partition Settings section choose "custom partition table csv".
 * 
 * BUGS
 *	  8-10-19 I had the same problem as 3-28-19, this time I removed the USB power supply from the wall and 
 *	     re-plugged and this immediately fixed the problem.
 *    3-28-19 Wlan suddenly would not connect until I removed the 'lasertag' wless entry, then it connected imediately.
 * 
 */
// ***************** ESP PIN ASSIGNMENTS *****************
/*
  D0      MAX31856 SDI also serial port
  D1      Serial port TXD
  D2      Unused
  D3      Serial port RXD
  D4      MAX31856 SDO
  D5      SENSOR 3
  D6-11   unusable (connected internally)
  D12     JTAG, LED BLUE
  D13     JTAG, LED GREEN
  D14     JTAG, LED RED
  D15     JTAG
  D16     MAX31856 SCK
  D17     unused
  D18     SENSOR 10
  D19     SENSOR 4
  D20 no pin
  D21     SENSOR 11
  D22     SENSOR 12
  D23     unused
  D24 no pin
  D25     SENSOR 1
  D26     SENSOR 2
  D27     MAX31856 CS
  D28 no pin
  D32     MCP2317 SCK
  D33     MCP2317 SDA
  D34     unused         INPUT-ONLY
  D35     unused         INPUT-ONLY
  D36     PB2            INPUT-ONLY
  D37, D38 no pin
  D39     PB1            INPUT-ONLY
       
  See https://randomnerdtutorials.com/esp32-pinout-reference-gpios/
*/


#include "tc_common.h"

// ****************************************************************************************************
// GLOBALS

// Indicates that a reset has been requested in this number of seconds.
volatile int ResetRequestSec = 0;
CDataPoint ValuesArr[MAX_SAMPLES];
// Time at boot used to caculate up time. This is set in TimeSetup().
time_t BootTime;
volatile int ValuesArrInd = 0;
std::queue<CDataPoint> SvrDataPointQ;
max31856_cfg_t max31856;
CConfig Config;
//float temp1;
//int Count = 0;
char strftime_buf[64];

#define BUF_SIZE_SKT 300
#define BUF_SIZE (300)
//int sock;
int sockSMTP;
int WifiAuthIndex = 0;
int WifiStatus = 0;
unsigned long long MACAddr;
// Indicates that this unit is being identified.
int DeviceFlags = 0;
int SystemStatusFlag = 0;
int ThermocoupleCurrent = 0;

//E_BLINKTYPE BlinkType = BLINK_OFF;
// This is the low level for dimming the LEDs. When set the leds will dim instead of blink.
//int LEDDimLowLevel = 0;

CStatusLED StatusLED;

// Indicates that the unit is identifying for this number of seconds.
volatile int IdentifySecs = 0;

volatile int Sw1Pressed = 0;
volatile int Sw2Pressed = 0;

// Number of seconds since we have successfully contacted the svr.
long TimeSvrConnectSec = 0;

// Current value of the MCP23017 ports.
int MCP23017CurVal = 0;

//char HostName[20];
long TimeSinceBootMS = 0;
//long TimeSinceLastMsgMS = 0;
// Indicates that the leds should show power on.
//bool PowerBlinkIndictor = 1;

CEventLog EventLog;

bool PauseTemperatureThread = 0;

// This holds the wifi authentication.
typedef struct {
	const char *SSID;
	const char *Pwd;
} s_WifiAuth;

CWifiSTACredentials WifiSTACredentials;

// Configure possible wireless networks here.
// Be sure to change this constant or we will crash.
// Note that this is zero-based, so with one entry use '0'. 
#define WIFIAUTH_LAST_INDEX 1
//s_WifiAuth WifiAuth[] = {
//	{"full_quiver", "samrizzo"},
////	{"pcbcguest", "jesuslovesme"},
//	{"effort_pi", "$JerRizzo5$"}
//};

static void obtain_time(void) {
	xEventGroupWaitBits(wifi_event_group, CONNECTED_BIT, false, true, portMAX_DELAY);
	initialize_sntp();

	time_t now = 0;
	struct tm timeinfo = {0,0,0,0,0,1970,0,0,0};

	ESP_LOGI(TAG, "Setting system time..\n");
	vTaskDelay(2000 / portTICK_PERIOD_MS);
	time(&now);
	localtime_r(&now, &timeinfo);
}

#include "lwip/apps/sntp.h"


static void initialize_sntp(void) {
	ESP_LOGI(TAG, "Initializing SNTP");
	sntp_setoperatingmode(SNTP_OPMODE_POLL); // 6-15-19 dgs $$$ THIS LINE CAUSES THE ASSERTION!
	sntp_setservername(0, (char*)"pool.ntp.org");
    
//    sntp_set_time_sync_notification_cb(TimeSyncNotification);
//    sntp_set_sync_mode(SNTP_SYNC_MODE_SMOOTH); // Added 2-10-20
	sntp_init();
}



static esp_err_t event_handler(void *ctx, system_event_t *event) {
    char s100[100];
    
	switch (event->event_id) {
		case SYSTEM_EVENT_AP_START:
			printf("Event:ESP32 is started in AP mode\n");
			break;
		
		case SYSTEM_EVENT_AP_STACONNECTED:
			xEventGroupSetBits(wifi_event_group, CLIENT_CONNECTED_BIT);
			break;

		case SYSTEM_EVENT_AP_STADISCONNECTED:
			xEventGroupSetBits(wifi_event_group, CLIENT_DISCONNECTED_BIT);
			break;		

	case SYSTEM_EVENT_STA_START:
			//printf("event_handler() SYSTEM_EVENT_STA_START\n");
			esp_wifi_connect();
			break;
		case SYSTEM_EVENT_STA_GOT_IP:
			//printf("event_handler() SYSTEM_EVENT_STA_GOT_IP\n");
			xEventGroupSetBits(wifi_event_group, CONNECTED_BIT);  	
			sprintf(s100,"My IP is " IPSTR "\n", IP2STR(&event->event_info.got_ip.ip_info.ip));  	

			//        printf("netmask: " IPSTR "\n", IP2STR(&event->event_info.got_ip.ip_info.netmask));
			//        printf("gw: " IPSTR "\n", IP2STR(&event->event_info.got_ip.ip_info.gw));
			//        printf("\n");
			fflush(stdout);
			WifiStatus = 1; // $$$ was 1
			break;
    	
		case SYSTEM_EVENT_STA_DISCONNECTED:
			// If wifi was never connected..
			if (WifiStatus == 0) {
				printf("event_handler() Wifi trying to connect to '%s' with pwd '%s'\n", WifiSTACredentials.SSID, WifiSTACredentials.Pwd);
				wifi_config_t sta_config;
				sta_config.sta.bssid_set = false;
    			strcpy((char*) sta_config.sta.ssid, WifiSTACredentials.SSID);
    			strcpy((char*) sta_config.sta.password, WifiSTACredentials.Pwd);

				esp_wifi_set_config(WIFI_IF_STA, &sta_config);
			}

			WifiStatus = 0;
			/* This is a workaround as ESP32 WiFi libs don't currently
				auto-reassociate. */
			//printf("event_handler() esp_wifi_connect\n");
			esp_wifi_connect();
		
			xEventGroupClearBits(wifi_event_group, CONNECTED_BIT);
			break;
		default:
			break;
	}
	return ESP_OK;
}

static int initialise_wifi(void) {
	tcpip_adapter_init();
	wifi_event_group = xEventGroupCreate();
	ESP_ERROR_CHECK(esp_event_loop_init(event_handler, NULL));
	wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
	ESP_ERROR_CHECK(esp_wifi_init(&cfg));
	ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));
	ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));

	wifi_config_t sta_config;
	sta_config.sta.bssid_set = false;
    strcpy((char*) sta_config.sta.ssid, WifiSTACredentials.SSID);
    strcpy((char*) sta_config.sta.password, WifiSTACredentials.Pwd);

	ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &sta_config));

	esp_wifi_stop();
	vTaskDelay(pdMS_TO_TICKS(1000));

	int r = esp_wifi_start();
	return r;
}

/**
 ** Determine if time has been obtained.
 ** 
 ** Return 0 if not valid, 1 if valid.
 ***/
int TimeValid() {
    time_t now;

    time(&now);
    
    if (now > 1570000000)
        return 1;
 
    return 0;
}

void TimeSetup(int ForceUpdate) {
	time_t now;
	struct tm timeinfo;

	time(&now);
	localtime_r(&now, &timeinfo);
	// Is time set?
	if(ForceUpdate || timeinfo.tm_year < (2016 - 1900)) {
//		ESP_LOGI(TAG, "Time is not set yet. Connecting to WiFi and getting time over NTP.");
		obtain_time();
		// update 'now' variable with current time
		time(&now);
	}

	// Set timezone to Eastern Standard Time and print local time
	setenv("TZ", "EST5EDT,M3.2.0/2,M11.1.0", 1);
	tzset();
	localtime_r(&now, &timeinfo);
	strftime(strftime_buf, sizeof (strftime_buf), "%c", &timeinfo);
    char s100[100];
//	sprintf (s100,"The current time is: %s\n", strftime_buf);
//    EventLog.Log(s100, ELogLevel::INFO, 1);
    
    // Set the boot time.
    BootTime = now;
}

//static void UART_Init() {
//	printf("UART_Init()\n");
//
//	/* Configure parameters of an UART driver,
//	 * communication pins and install the driver */
//	uart_config_t uart_config = {
//		.baud_rate = 1200,
//		.data_bits = UART_DATA_8_BITS,
//		.parity = UART_PARITY_DISABLE,
//		.stop_bits = UART_STOP_BITS_1,
//		.flow_ctrl = UART_HW_FLOWCTRL_DISABLE
//	};
//	uart_param_config(UART_NUM_1, &uart_config);
//	// RXD pin is GPIO 5
//	uart_set_pin(UART_NUM_1, UART_PIN_NO_CHANGE, GPIO_NUM_5, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
//	uart_driver_install(UART_NUM_1, BUF_SIZE * 2, 0, 0, NULL, 0);
//
//	// Configure a temporary buffer for the incoming data
//	data = (uint8_t *) malloc(BUF_SIZE);
//}

/**
 * Get the WIFI channel and signal strength.
 * 
 * @param info
 */
void getWifiInfo(SWifiInfo *info) {
	info->rssi = 0;
	info->channel = 0;
	wifi_ap_record_t wifidata;
	esp_wifi_sta_get_ap_info(&wifidata);
	if (wifidata.primary != 0) {
		info->rssi = wifidata.rssi;
		info->channel = wifidata.primary;
	}
}


/**
 ** Save the current data point to the data array.
 ***/
void SaveDataPointToArray(CDataPoint DataPoint) {
	if (Config.EnableLogging) {
		//printf("Thread_SaveValuesToArray: %u:%u:%u t0=%.1f, t1=%.1f, t2=%.1f, t3=%.1f, t4=%.1f ValuesArrInd=%u\n",timeinfo.tm_hour,timeinfo.tm_min,timeinfo.tm_sec,
		//		  Config.ChannelsAr[0].ValueCurrent,Config.ChannelsAr[1].ValueCurrent,Config.ChannelsAr[2].ValueCurrent,Config.ChannelsAr[3].ValueCurrent,Config.ChannelsAr[4].ValueCurrent, ValuesArrInd);

			// Add the new value to the array.
		for (int i=0; i<NUM_CHANNELS; i++)
			ValuesArr[ValuesArrInd].val[i] = DataPoint.val[i];

		ValuesArr[ValuesArrInd].time = DataPoint.time;

		ValuesArrInd++;
		if (ValuesArrInd >= MAX_SAMPLES)
			ValuesArrInd = 0;	
	} else 
		printf("Logging disabled\n");
}

void NVS_Init() {
	// Initialize NVS
	esp_err_t err = nvs_flash_init();
	if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
		// NVS partition was truncated and needs to be erased
		// Retry nvs_flash_init
		ESP_ERROR_CHECK(nvs_flash_erase());
		err = nvs_flash_init();
	}
	ESP_ERROR_CHECK(err);
}

//esp_err_t Read(char *tag, char *value, size_t len) {
//	nvs_handle my_handle;
//
//	// Get this target's name.
//	esp_err_t err = nvs_open("preferences", NVS_READWRITE, &my_handle);
//
//	if (err != ESP_OK)
//		printf("Error (%d) opening NVS handle!\n", err);
//	else {
//		err = nvs_get_str(my_handle, tag, value, &len);
//		//printf("nvs_get_str: err=%X, '%s'\n",err,value);
//	}
//
//	nvs_close(my_handle);
//	return err;
//}

//esp_err_t Write(char *tag, char *value) {
//	nvs_handle my_handle;
//
//	// Get this target's name.
//	esp_err_t err = nvs_open("preferences", NVS_READWRITE, &my_handle);
//
//	if (err == ESP_OK) {
//		err = nvs_set_str(my_handle, tag, value);
//	} else
//		printf("Error (%d) opening NVS handle!\n", err);
//
//	nvs_close(my_handle);
//	return err;
//}

void Thread_CPUTimeUpdate() {
	while (1) {
		vTaskDelay(10 / portTICK_PERIOD_MS);

		TimeSinceBootMS++;
	}
}

void Replace(string& source, string const& find, string const& replace) {
	for (string::size_type i = 0; (i = source.find(find, i)) != string::npos;) {
		source.replace(i, find.length(), replace);
		i += replace.length();
	}
}


/**
 * Parse an html header string.
 * 
 * @param buf
 * @param buflen
 * @param StrArr
 * @param StrMaxlen
 */
///
int Parse(char *buf, int buflen, string StrArr[], int StrMaxlen) {
	char *ptr = buf;
	int i = 0;
	char s[5];

	for (i=0; i<StrMaxlen; i++)
		StrArr[i].clear();

	i=0;
	// While EOL not detected and we are not at the end of the buffer..
	while (*ptr != '\n' && (int)(ptr-buf) < buflen) {
		//printf("While\n");
		
		//printf("i=%u *ptr=%c\n",i,*ptr);
		// If this is a separator..
		if ( strchr("?=& ",*ptr) ) {
			// Save the separator as the current array token.
			if (StrArr[i].size() > 0 && i < StrMaxlen-1)
				i++;
			s[0] = *ptr; s[1] = 0;
			StrArr[i] = s;
			if (i < StrMaxlen-1)
				i++;
		}
		else {
			// Add this char to the current array value.
			StrArr[i] += (char)(*ptr);
		}
		ptr++;
	}
	return i;
}

// for string delimiter
vector<string> split(string s, string delimiter) {
	size_t pos_start = 0, pos_end, delim_len = delimiter.length();
	string token;
	vector<string> res;

	while ((pos_end = s.find(delimiter, pos_start)) != string::npos) {
		token = s.substr(pos_start, pos_end - pos_start);
		pos_start = pos_end + delim_len;
		res.push_back(token);
	}

	res.push_back(s.substr(pos_start));
	return res;
}



//void Thread_BatteryTest() {
//	adc1_config_width(ADC_WIDTH_9Bit);
//	adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_DB_11);
//
//	// https://esp-idf.readthedocs.io/en/v2.0/api/peripherals/dac.html
//	// For curve fitting see https://mycurvefit.com/
//	while (1) {
//		float val = adc1_get_raw(ADC1_CHANNEL_0); // dgs: was adc1_get_voltage
////		ClientStats.BatteryVoltage = (0.00951 * val + 1.263)*10;
//		//printf("Battery=%d\n",ClientStats.BatteryVoltage);
//		//dac_out_voltage(DAC_CHANNEL_1, val/2);
//		delay(1000);
//	}
//}

int SMTPWaitReply(int WaitTimeMS, string &s) {
	char SMTPBuf[200];
	int len;

	// While there is no reply..
	do {
		// Get a CMsg from the server.
		len = read(sockSMTP, SMTPBuf, BUF_SIZE_SKT);

		// If disconnect occurred..
		if (len < 0) {
			printf("SMTP Disconnect\n");
			return len;
		}

		DelayMS(1);
	} while (len == 0 && WaitTimeMS-- > 0);

	if (len > 0) {
		SMTPBuf[len] = 0;
		s = SMTPBuf;
		printf("SMTP SVR: %s\n", SMTPBuf);
	}
	return len;
}

void InitGPIO() {

#if !DEBUGGER
    // Init LED outputs
    LEDPwmInit();
//	gpio_pad_select_gpio(LEDR_GPIO_NUM);
//	gpio_set_direction(LEDR_GPIO_NUM, GPIO_MODE_OUTPUT);
//	gpio_set_level(LEDR_GPIO_NUM, 0);
//	
//	gpio_pad_select_gpio(LEDG_GPIO_NUM);
//	gpio_set_direction(LEDG_GPIO_NUM, GPIO_MODE_OUTPUT);
//	gpio_set_level(LEDG_GPIO_NUM, 1);
//	
//	gpio_pad_select_gpio(LEDB_GPIO_NUM);
//	gpio_set_direction(LEDB_GPIO_NUM, GPIO_MODE_OUTPUT);
//	gpio_set_level(LEDB_GPIO_NUM, 1);
#endif
    // Configure pushbutton switch I/O.
    gpio_pad_select_gpio(SW1_GPIO_NUM);
    gpio_set_direction(SW1_GPIO_NUM, GPIO_MODE_INPUT);
    gpio_pad_select_gpio(SW2_GPIO_NUM);
    gpio_set_direction(SW2_GPIO_NUM, GPIO_MODE_INPUT); 
}

const char* SYS_STATUS_WARNING_S = "WARNING";
const char* SYS_STATUS_ERROR_S = "ERROR";
const char* SYS_STATUS_OK_S = "OK";

void CStatusLED::SetStatus(int status, string DetailStr) {  
    char s200[200];
    const char *StatusStrPtr;
        
    if (status == SYS_STATUS_WARNING) {
        StatusStrPtr = SYS_STATUS_WARNING_S;
        SetColor(YELLOW);
        }
    else if (status == SYS_STATUS_ERR) {
        StatusStrPtr = SYS_STATUS_ERROR_S;
        SetColor(RED);
    }
	else {
    	StatusStrPtr = SYS_STATUS_OK_S;
    	SetColor(GREEN);
	}
	
    if (status != SystemStatusFlag) {
        if (DetailStr.length() > 0 && DetailStr.length() < 120)
            sprintf(s200, "System status changed to %s: %s", StatusStrPtr,DetailStr.c_str() );
        else
            sprintf(s200, "System status changed to %s", StatusStrPtr);
        EventLog.Log(s200);
        
	    SystemStatusFlag = status;
    }     
}

void CStatusLED::Blank() {
    SetLEDParms(0);
    Blanked = 1;  
}

void CStatusLED::Restore() {
    SetColor(LEDColor);
    Blanked = 0;
}

void CStatusLED::SetColor(int color) {
    if (LEDColor != color)
        // Prevent the next call to Invert() from blanking.
        Blanked = 1;  

    LEDColor = color;
    SetLEDParms(LEDColor);
}

void CStatusLED::Invert() {
    if (Blanked)
        Restore();
    else
        Blank();
}

/**
 * Read the configuration from the VFS.
 * 
 * See https://github.com/espressif/esp-idf/tree/master/examples/storage/nvs_rw_blob
 * 
 * @return 
 */
esp_err_t CWifiSTACredentials::Read() {
	printf("Restoring wifi credentials from FLASH..\n");
	esp_err_t err;
	size_t required_size;
	nvs_handle my_handle;
	
	// Open the NVS.
	err = nvs_open("wifi", NVS_READWRITE, &my_handle);

	if (err != ESP_OK)
		printf("Error (%d) opening NVS handle!\n", err);
	else {
    	required_size = sizeof(CWifiSTACredentials);
		//printf("required_size=%u\n", (int)required_size);
		
		if (required_size > 0) {
    		err = nvs_get_blob(my_handle, "wifi", this, &required_size);
			if (err != ESP_OK) {
				printf("Error nvs_get_blob.\n");
			}
		}
	}	
	nvs_close(my_handle);
    
    printf("Wifi credentials restored: SSID='%s', PWD='%s'\n", WifiSTACredentials.SSID, WifiSTACredentials.Pwd);
		
	// Test all config values for ranges.
//	if ( Config.CheckValues() )
//		err = ESP_FAIL;
	
	return err;
}

/**
 * Write the configuration to the VFS.
 * 
 * @return 
 */
esp_err_t CWifiSTACredentials::Write() {
	esp_err_t err;
	size_t required_size;
	nvs_handle my_handle;

    printf("Saving wifi credentials to flash.\n");
	
	// Open the NVS.
	err = nvs_open("wifi", NVS_READWRITE, &my_handle);
    if (err != ESP_OK) {
        printf("Error (%s) opening NVS handle!\n", esp_err_to_name(err));
    } 
    
	// Write the config to the VFS.
	required_size = sizeof(CWifiSTACredentials);
    err = nvs_set_blob(my_handle, "wifi", this, required_size);

	if (err != ESP_OK) 
		printf("Error in nvs_set_blob.\n");

	// Commit
	err = nvs_commit(my_handle);
	if (err != ESP_OK) 
		printf("NVS commit error.\n");

	nvs_close(my_handle);
	
	return err;
}

/**
 * Select a thermocouple input.
 * 
 * @param n
 */
void ThermocoupleSelect(int n) {
    MCP23017CurVal = (MCP23017CurVal & ~0xe000) | (n << 13);
    MCP23017WriteBoth(MCP23017CurVal);
}


/**
 * Light or extinguish the given channel LED.
 *
 */
void ChannelLED(int LEDNum, int Enable) {
    if (LEDNum > 11 || LEDNum < 0)
        return;
    
    if (Enable)
        MCP23017CurVal = (MCP23017CurVal & ~(1 << LEDNum));
    else
        MCP23017CurVal = (MCP23017CurVal |  (1 << LEDNum));
    
    MCP23017WriteBoth(MCP23017CurVal);
}

///
/*		
 * Get a sample given the offset from the current index.
 * 
 * @param offset
 * @param Sample
 * @return -1 on error.
 */
int GetSample(int offset,CDataPoint &Sample) {
	if (offset < 0 || offset > MAX_SAMPLES-1)
		return -1;
	
	int i = ValuesArrInd - offset - 1;
	
	if (i < 0)
		i += MAX_SAMPLES;
	
	Sample = ValuesArr[i];
	return 0;
}

	
char *Trim(char *str) {
	char *end;

	// Trim leading space
	while(isspace((unsigned char)*str)) str++;

	if (*str == 0)  // All spaces?
	  return str;

	// Trim trailing space
	end = str + strlen(str) - 1;
	while (end > str && isspace((unsigned char)*end)) end--;

	// Write new null terminator character
	end[1] = '\0';

	return str;
}

// *******************************************************************************************
// THIS IS THE AP CODE
static void start_dhcp_server() {
    
	// initialize the tcp stack
	tcpip_adapter_init();
	// stop DHCP server
	ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP));
	// assign a static IP to the network interface
	tcpip_adapter_ip_info_t info;
	memset(&info, 0, sizeof(info));
	IP4_ADDR(&info.ip, 192, 168, 1, 1);
	IP4_ADDR(&info.gw, 192, 168, 1, 1); //ESP acts as router, so gw addr will be its own addr
	IP4_ADDR(&info.netmask, 255, 255, 255, 0);
	ESP_ERROR_CHECK(tcpip_adapter_set_ip_info(TCPIP_ADAPTER_IF_AP, &info));
	// start the DHCP server   
	ESP_ERROR_CHECK(tcpip_adapter_dhcps_start(TCPIP_ADAPTER_IF_AP));
	printf("DHCP server started \n");
}
static void initialise_wifi_in_ap(void)
{
	esp_log_level_set("wifi", ESP_LOG_NONE);  // disable wifi driver logging
	wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
	ESP_ERROR_CHECK(esp_wifi_init(&cfg));
	ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));
	ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));

	// configure the wifi connection and start the interface
	wifi_config_t ap_config;
	
	ap_config.ap.ssid_len = 0;
	ap_config.ap.channel = 0;
	ap_config.ap.authmode = AP_AUTHMODE;
	ap_config.ap.ssid_hidden = 0;
	ap_config.ap.max_connection = AP_MAX_CONNECTIONS;
	ap_config.ap.beacon_interval = AP_BEACON_INTERVAL;
	strcpy((char*)ap_config.ap.ssid, AP_SSID);
	strcpy((char*)ap_config.ap.password,AP_PASSPHARSE);
	
	ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &ap_config));
	ESP_ERROR_CHECK(esp_wifi_start());
	printf("ESP WiFi started in AP mode \n");
}

// print the list of connected stations
void printStationList() 
{
	printf(" Connected stations:\n");
	printf("--------------------------------------------------\n");
	
	wifi_sta_list_t wifi_sta_list;
	tcpip_adapter_sta_list_t adapter_sta_list;
   
	memset(&wifi_sta_list, 0, sizeof(wifi_sta_list));
	memset(&adapter_sta_list, 0, sizeof(adapter_sta_list));
   
	ESP_ERROR_CHECK(esp_wifi_ap_get_sta_list(&wifi_sta_list));	
	ESP_ERROR_CHECK(tcpip_adapter_get_sta_list(&wifi_sta_list, &adapter_sta_list));
	
	for (int i = 0; i < adapter_sta_list.num; i++) {
		
		tcpip_adapter_sta_info_t station = adapter_sta_list.sta[i];
		printf("%d - mac: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x - IP: %s\n",
			i + 1,
			station.mac[0],
			station.mac[1],
			station.mac[2],
			station.mac[3],
			station.mac[4],
			station.mac[5],
			ip4addr_ntoa(&(station.ip)));
	}
	
	printf("\n");
}

void print_sta_info(void *pvParam) {
	printf("print_sta_info task started \n");
	while (1) {	
		EventBits_t staBits = xEventGroupWaitBits(wifi_event_group, CLIENT_CONNECTED_BIT | CLIENT_CONNECTED_BIT, pdTRUE, pdFALSE, portMAX_DELAY);
		if ((staBits & CLIENT_CONNECTED_BIT) != 0) printf("New station connected\n\n");
		else printf("A station disconnected\n\n");
		printStationList();
	}
}

std::string str_toupper(std::string str) {
    std::string loc;
    for (std::string::size_type i = 0; i < str.length(); ++i)
        loc += std::toupper(str[i]);
    return loc;
}

/**
 ** Update the time once per hour.
 ***/
void Thread_UpdateTime(void *pvParameter) {
    while (1) {
        // Delay for 1 hr
        vTaskDelay(pdMS_TO_TICKS(60 * 60  * 1000));	
        TimeSetup(1);
    }
}

void PrintCurrentTime() {
    struct tm timeinfo;
    time_t now = time(0);
    
    localtime_r(&now, &timeinfo);
    strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
    printf("%s\n", strftime_buf);    
}

/**
 ** If we have not been able to contact the server for 10 minutes then reboot.
 ** Once per day set the time.
 ***/
void Thread_OncePerSecond(void *pvParameters) {   
    int Seconds = 0;
    char s200[200];
    bool LoggedErrorState = 0;
    
    while (1) {      
        // If we are in an error state because of a WIFI error (or any other connection error)..
        //    Wait a little while and then reboot. hopefully this will resolve the problem.
        if(SystemStatusFlag == SYS_STATUS_ERR) {
            sprintf(s200,"Rebooting in %lu sec\n", ERROR_REBOOT_TIME_SEC-TimeSvrConnectSec);
            if (!LoggedErrorState) {
                LoggedErrorState = 1;
                EventLog.Log(s200,ELogLevel::CRITICAL, 1);
            }
            // If time to reboot..
            if (TimeSvrConnectSec++ > ERROR_REBOOT_TIME_SEC) {
                printf("\n\n**** REBOOTING!\n\n");
                EventLog.Log("REBOOTING NOW..", ELogLevel::CRITICAL, 1);
                esp_restart();
            }
        } else {
            if (TimeSvrConnectSec > 0) {
                TimeSvrConnectSec = 0;
                EventLog.Log("Reboot cancelled.");
            }
        }

        // Handle a reset request.
        if (ResetRequestSec > 0) {
            if (--ResetRequestSec == 0) {
                EventLog.Log("Rebooting now!");
                esp_restart();
            }
        }
        
        if (Seconds++ == 60) {
            Seconds = 0;
            
 //            PrintCurrentTime();
        }
        
        if (IdentifySecs > 0) {
            if (--IdentifySecs == 0) {
                EventLog.Log("Identify OFF");
                StatusLED.SetStatus(SYS_STATUS_OK);
            }                
        }
        
        if (Sw1Pressed) {
            EventLog.Log("Sw1 Pressed", ELogLevel::INFO);
            Sw1Pressed = 0;          

            printf("Sw1 pressed!\n");
        }
        
        if (Sw2Pressed) {
            Sw2Pressed = 0;          
            
            EventLog.Log("Sw2 Pressed", ELogLevel::INFO);
        }            
        // Delay 1 second.
        vTaskDelay( pdMS_TO_TICKS(1000) );	
    }
}

/**
 ** This thread polls the switches.
 ** 
 ** NOTE that I tried to get the GPIO interrupt to work but I get spurious interrupts.
 ***/
void Thread_SwitchPoller(void *pvParameters) { 
    while (1) {
        if ( !gpio_get_level(SW1_GPIO_NUM) )
            Sw1Pressed = 1;
        if ( !gpio_get_level(SW2_GPIO_NUM) )
            Sw2Pressed = 1;
        
        // Delay 1 second.
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

/**
 ** Get the Json string for this entry.
 ** 
*/
string CEventLogEntry::Json() {
    char s200[200];
    
    string JsonStr = "[";
    sprintf(s200, "%lu,%u,", (long)time, (int)level);
    JsonStr += s200;
    JsonStr += "\"" + text + "\"";
    JsonStr += "]";
    return JsonStr;
}

void CEventLog::Log(std::string text, ELogLevel Level, bool Print) {
    CEventLogEntry EventLogEntry;
    
    // Remove all \n chars.
    std::replace(text.begin(), text.end(), '\n', ' ');
    
    if (Level >= CurLevel) {
        EventLogEntry.text = text;
        time(&EventLogEntry.time);
        EventLogEntry.level = Level;
    
        // Push the data point to the server queue.
        if(EventLogQueue.size() < LOG_QUEUE_SIZE) {
            EventLogQueue.push(EventLogEntry);
        }
        
        if (Print || PRINT_ALL_LOGS) {
            printf("**Log():%s\n", text.c_str());
            fflush(stdout);
        }
    }
}

/**
 ** Get the JSON string for all log entries.
 ** 
 ** Don't remove the entries from the queue; we will do this later!
 ***/
string CEventLog::Json() {
    string JsonStr;
    
    if (EventLogQueue.size() <= 0)
        return JsonStr;
    
    JsonStr += "\"log\":[";

    CEventLogEntry Event;
    
    while (EventLogQueue.size() > 0) {
        // Get a data point from the queue.
        Event = EventLogQueue.front();
        
        EventLogQueue.pop();
        JsonStr += Event.Json() + ",";
    }
    // Removed the last comma from the string.
    JsonStr.pop_back();
    
    JsonStr += "]";
    
    return JsonStr;
}

void EventLogLog(char *s) {
    EventLog.Log(s);    
}

int CaptivePortal(void);
    
void app_main(void) {
    char s200[200];    
    
    // Disable the annoying ESP-IDF messages. (or set to ESP_LOG_INFO)
    esp_log_level_set("*", ESP_LOG_NONE);
	    
    sprintf(s200, "**** Ver %s %s ****", VERSION, COPYRIGHT);
    EventLog.Log(s200, ELogLevel::INFO, 1);
    sprintf(s200, "Webserver:%s, WebURL:%s", WEB_SERVER, WEB_URL);
    EventLog.Log(s200, ELogLevel::INFO, 1);
    
    printf("\nESP-IDF ver: %s\n", esp_get_idf_version());
    printf("DEBUGGER:%u\n"
    	"PRINT_TEMPERATURE_VALUES:%u\n"
    	"PRINT_SENSOR_ERRORS:%u\n"
    	"PRINT_ONEWIRE_RESET_PULSE:%u\n"
    	"PRINT_CURRENT_DATAPOINT_TIME:%u\n"
        "PRINT_WEB_CONN_INFO:%u\n",
        DEBUGGER,
        PRINT_TEMPERATURE_VALUES,
        PRINT_SENSOR_ERRORS,
        PRINT_ONEWIRE_RESET_PULSE,
        PRINT_CURRENT_DATAPOINT_TIME,
        PRINT_WEB_CONN_INFO);

    // Initialize NVS and read the WIFI credentials.
    esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        // 1.OTA app partition table has a smaller NVS partition size than the non-OTA
        // partition table. This size mismatch may cause NVS initialization to fail.
        // 2.NVS partition contains data in new format and cannot be recognized by this version of code.
        // If this happens, we erase NVS partition and initialize NVS again.
        printf("Erasing NVS..\n");
        ESP_ERROR_CHECK(nvs_flash_erase());
        err = nvs_flash_init();
    }
    ESP_ERROR_CHECK(err);
    
    // Read the wifi SSID and password from NVM.
    WifiSTACredentials.Read();
    
    // Init the GPIO.
    InitGPIO();
    
    // If SW1 is pressed..
    // NOTE that the GPIO is different for the older board.
    if(!gpio_get_level(SW1_GPIO_NUM))
        // Go into 'Captive Portal' mode to get the wifi credentials.
        // NOTE that this function performs a hardware reset so it does not return.
        CaptivePortal(); 
    
    xTaskCreatePinnedToCore((TaskFunction_t) &Thread_SwitchPoller, "Thread_SwitchPoller", 2048, NULL, 1, NULL, 0);
     
//    LEDColorTest();
    
    // Set status led
	StatusLED.SetColor(YELLOW);
         
    // Init the MCP23017 I2C interface.
    esp_err_t ret = mcp23017_init(I2C_SDA, I2C_SCL);
    // Turn all LEDs off.
    MCP23017CurVal = 0xffff;
    MCP23017WriteBoth(MCP23017CurVal);
    
    // Disable brownout detector.
    WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); 
	
    // Init the values array.
    for(int i = 0 ; i < MAX_SAMPLES ; i++)
    	ValuesArr[i].time = 0;
	
    //*******************************************************************
    // IMPORTANT: THE FOLLOWING NEEDS TO BE DONE AFTER Config.Init()!
    // Init the DS18B20 sensors.
    Config.ChannelsAr[0].SetChannel18b20((gpio_num_t)25);
    Config.ChannelsAr[1].SetChannel18b20((gpio_num_t)26);
    Config.ChannelsAr[2].SetChannel18b20((gpio_num_t)5);
    Config.ChannelsAr[3].SetChannel18b20((gpio_num_t)19);
    Config.ChannelsAr[4].SetChannelMAX31856(0);
    Config.ChannelsAr[5].SetChannelMAX31856(1);
    Config.ChannelsAr[6].SetChannelMAX31856(2);
    Config.ChannelsAr[7].SetChannelMAX31856(3);
    Config.ChannelsAr[8].SetChannelMAX31856(4);
    Config.ChannelsAr[9].SetChannel18b20((gpio_num_t)18);
    Config.ChannelsAr[10].SetChannel18b20((gpio_num_t)21);
    Config.ChannelsAr[11].SetChannel18b20((gpio_num_t)22);
    //*******************************************************************

    // LED test
    for(int i = 0 ; i < 12 ; i++) {
        ChannelLED(i, 1);
        vTaskDelay(pdMS_TO_TICKS(50));	
    } 
    // LED test
    for(int i = 0 ; i < 12 ; i++) {
        ChannelLED(i, 1);
        vTaskDelay(pdMS_TO_TICKS(50));	
    }  
    
    // Leave all LEDs on for 1 second.
    vTaskDelay(pdMS_TO_TICKS(1000));	
    
    // $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
#if 0
    	int count = 0;
    while (1) {
        float v1 = Config.ChannelsAr[0].T18b20.ds18b20_get_temp();
        float v2 = Config.ChannelsAr[1].T18b20.ds18b20_get_temp();
        float v3 = Config.ChannelsAr[2].T18b20.ds18b20_get_temp();
        float v4 = Config.ChannelsAr[3].T18b20.ds18b20_get_temp();
        float v5 = Config.ChannelsAr[9].T18b20.ds18b20_get_temp();
        float v6 = Config.ChannelsAr[10].T18b20.ds18b20_get_temp();
        float v7 = Config.ChannelsAr[11].T18b20.ds18b20_get_temp();
		
        printf("%u %.1f %.1f %.1f %.1f %.1f %.1f %.1f\n", count++, v1, v2, v3, v4, v5, v6, v7);
        vTaskDelay(pdMS_TO_TICKS(200)); 
    }
#endif	 
		
    // This is extra code which really does nothing except help to fix the 
    // intermittent wifi connection problem.
    // If wifi doesn't connect then either enable or disable this bit of code.
#ifdef FIX_WIFI_CONNECTION_PROBLEM
    	vTaskDelay(pdMS_TO_TICKS(200));
#endif

    // Start reading the temperature sensors. This thread has the highest priority 
    // since it uses precise delays to read the DS18B20 sensors. It was found that 
    // a low priority results in more checksum errors.
    // 4-25-21 Changed usStackDepth from 2048 to 4096 after stack overflow error (after I added some code).
    // 4-23-20 Lowered to 5 but then got 18B20 checksum errors so I raised it again to configMAX_PRIORITIES.
    // 5-3-19 I lowered this from 8 to 5 because the time was getting way behind.
    // 10-6-19 Moved this to BEFORE initialise_wifi() so the sensor LEDs will indicate valid sensors right away. 
    xTaskCreate(&Thread_ReadTemperature, "Thread_ReadTemperature", 4096, NULL, configMAX_PRIORITIES, NULL);

    // Init the wifi connection.
    if(initialise_wifi())
    	printf("ERROR INITING WIFI!!\n");
	
    // Read the MAC address.
    uint8_t mac[6];
    system_efuse_read_mac(mac);
	
//    sprintf(s200, "MAC: %02X:%02X:%02X:%02X:%02X:%02X\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
//    EventLog.Log(s200, ELogLevel::INFO, 1);

    MACAddr = ((long long)mac[0] << 40) + ((long long)mac[1] << 32) + ((long long)mac[2] << 24)
    	+ ((long long)mac[3] << 16) + ((long long)mac[4] << 8) + (long long)mac[5]; 
	
    // Set the host name.
    // Don't put a space in the hostname or it won't update!
    // If done properly the router will show the new hostname immediately.
    //	string s(Config.HostName);
    char s100[100], s120[120];
    sprintf(s100, "CloudLogger_%02X:%02X", mac[4], mac[5]);    
//    sprintf(s120, "My HostName is %s.\n", s100);
//    EventLog.Log(s120, ELogLevel::INFO, 1);
    tcpip_adapter_set_hostname(TCPIP_ADAPTER_IF_STA, s100);

    // I'm not sure why, but without this we get watchdog timer errors.
    // Wait here until wifi is connected.
//    printf("Connecting to WIFI with SSID '%s' and pwd '%s'..\n", WifiSTACredentials.);
    xEventGroupWaitBits(wifi_event_group, CONNECTED_BIT, false, true, portMAX_DELAY);

    // Set low power wifi mode. This alternates between 50mA and 100mA.
    // **** MAYBE WAIT UNTIL WE ARE CONNECTED BEFORE DOING THIS??? ****
    // See https://github.com/espressif/esp-idf/blob/master/examples/wifi/power_save/main/power_save.c
    //	esp_wifi_set_ps(WIFI_PS_MODEM);

    	// see http://esp32.info/docs/esp_idf/html/dd/d3c/group__xTaskCreate.html
    	//	xTaskCreatePinnedToCore((TaskFunction_t) & Thread_BatteryTest, "Thread_BatteryTest", 2048, NULL, 1, NULL, 0);
    	//	xTaskCreatePinnedToCore((TaskFunction_t) & Thread_Beep, "Thread_Beep", 2048, NULL, 1, NULL, 0);
    	// xTaskCreate(&http_server, "http_server", 15000, NULL, 5, NULL);

    	// Get the current time and set up the time server.
    	printf("Configuring the time..\n");
    TimeSetup(1);

    // Set status led
    StatusLED.SetStatus(SYS_STATUS_OK);
	
    xTaskCreate(&Thread_OncePerSecond, "Thread_OncePerSecond", 2048, NULL, 1, NULL);
    xTaskCreate(&Thread_SendDataToSvr, "Thread_SendDataToSvr", 4096, NULL, 5, NULL);
    xTaskCreate(&FirmwareUpgradeTask,  "FirmwareUpgradeTask",  8192, NULL, 5, NULL);

    // ******************************************************************************************************************

#if CONFIG_EXAMPLE_CONNECT_WIFI
    /* Ensure to disable any WiFi power save mode, this allows best throughput
     * and hence timings for overall OTA operation.
     */
    esp_wifi_set_ps(WIFI_PS_NONE);
#endif // CONFIG_EXAMPLE_CONNECT_WIFI
}


esp_err_t _http_event_handler(esp_http_client_event_t *evt)
{
    switch (evt->event_id) {
    case HTTP_EVENT_ERROR:
        ESP_LOGD(TAG, "HTTP_EVENT_ERROR");
        break;
    case HTTP_EVENT_ON_CONNECTED:
        ESP_LOGD(TAG, "HTTP_EVENT_ON_CONNECTED");
        break;
    case HTTP_EVENT_HEADER_SENT:
        ESP_LOGD(TAG, "HTTP_EVENT_HEADER_SENT");
        break;
    case HTTP_EVENT_ON_HEADER:
        ESP_LOGD(TAG, "HTTP_EVENT_ON_HEADER, key=%s, value=%s", evt->header_key, evt->header_value);
        break;
    case HTTP_EVENT_ON_DATA:
        ESP_LOGD(TAG, "HTTP_EVENT_ON_DATA, len=%d", evt->data_len);
        break;
    case HTTP_EVENT_ON_FINISH:
        ESP_LOGD(TAG, "HTTP_EVENT_ON_FINISH");
        break;
    case HTTP_EVENT_DISCONNECTED:
        ESP_LOGD(TAG, "HTTP_EVENT_DISCONNECTED");
        break;
    }
    return ESP_OK;
}

void FirmwareUpgradeTask(void * pvParameter) {
    xEventGroupWaitBits(wifi_event_group, CONNECTED_BIT, false,true,portMAX_DELAY);
    
    esp_http_client_config_t config;
    config.url = FIRMWARE_UPGRADE_URL;
    config.cert_pem = (char*)0;
    config.event_handler = _http_event_handler;
    config.buffer_size = 512; // dgs - added to fix bug: this was not init'd and caused the upgrade to fail.
    // config.port dgs - See note about FIRMWARE_UPGRADE_PORT in tc_common .h
    config.disable_auto_redirect = 1;

    #ifdef CONFIG_EXAMPLE_SKIP_COMMON_NAME_CHECK
    config.skip_cert_common_name_check = true;
    #endif
    
    while (1) {
        if (FirmwareUpgradeInProcess) {
            EventLog.Log("Upgrading firmware...");
            
            // Pause the ReadTemperature thread.
            PauseTemperatureThread = 1;
            
            StatusLED.SetStatus(SYS_STATUS_WARNING, "Firmware upgrade complete.. restarting.");
            vTaskDelay(1000 / portTICK_PERIOD_MS);
            
            esp_err_t ret = esp_https_ota(&config);
            if (ret == ESP_OK) {
                ResetRequestSec = REBOOT_DELAY_TIME;
                while (1) {
                    vTaskDelay(1000 / portTICK_PERIOD_MS);
                }
            }
            else {
                StatusLED.SetStatus(SYS_STATUS_ERR, "Error upgrading firmware");
                EventLog.Log("Firmware upgrade failed.");
                FirmwareUpgradeInProcess = 0;
                PauseTemperatureThread = 0;
                }
        }
        vTaskDelay(1000 / portTICK_PERIOD_MS);
     }
}

/**
 * Init the pulse-width-modulation timers for the LEDs.
 */
void LEDPwmInit(void) {
    //	gpio_pad_select_gpio(LEDR_GPIO_NUM);
    //	gpio_set_direction(LEDR_GPIO_NUM, GPIO_MODE_OUTPUT);
    //	gpio_set_level(LEDR_GPIO_NUM, 0);
    //	
    //	gpio_pad_select_gpio(LEDG_GPIO_NUM);
    //	gpio_set_direction(LEDG_GPIO_NUM, GPIO_MODE_OUTPUT);
    //	gpio_set_level(LEDG_GPIO_NUM, 1);
    //	
    //	gpio_pad_select_gpio(LEDB_GPIO_NUM);
    //	gpio_set_direction(LEDB_GPIO_NUM, GPIO_MODE_OUTPUT);
    //	gpio_set_level(LEDB_GPIO_NUM, 1);    
    ledc_channel_config_t ledc_channel_red = { 0 }, ledc_channel_green = { 0 }, ledc_channel_blue = { 0 };
    
    ledc_channel_red.gpio_num = LEDR_GPIO_NUM;
    ledc_channel_red.speed_mode = LEDC_HIGH_SPEED_MODE;
    ledc_channel_red.channel = LEDC_CHANNEL_1;
    ledc_channel_red.intr_type = LEDC_INTR_DISABLE;
    ledc_channel_red.timer_sel = LEDC_TIMER_1;
    ledc_channel_red.duty = 0;

    ledc_channel_green.gpio_num = LEDG_GPIO_NUM;
    ledc_channel_green.speed_mode = LEDC_HIGH_SPEED_MODE;
    ledc_channel_green.channel = LEDC_CHANNEL_2;
    ledc_channel_green.intr_type = LEDC_INTR_DISABLE;
    ledc_channel_green.timer_sel = LEDC_TIMER_1;
    ledc_channel_green.duty = 0;

    ledc_channel_blue.gpio_num = LEDB_GPIO_NUM;
    ledc_channel_blue.speed_mode = LEDC_HIGH_SPEED_MODE;
    ledc_channel_blue.channel = LEDC_CHANNEL_3;
    ledc_channel_blue.intr_type = LEDC_INTR_DISABLE;
    ledc_channel_blue.timer_sel = LEDC_TIMER_1;
    ledc_channel_blue.duty = 0;

    ledc_timer_config_t ledc_timer = { (ledc_mode_t) 0 };
    ledc_timer.speed_mode = LEDC_HIGH_SPEED_MODE;
    ledc_timer.bit_num = LEDC_TIMER_10_BIT;
    ledc_timer.timer_num = LEDC_TIMER_1;
    ledc_timer.freq_hz = 25000;

    ESP_ERROR_CHECK(ledc_channel_config(&ledc_channel_red));
    ESP_ERROR_CHECK(ledc_channel_config(&ledc_channel_green));
    ESP_ERROR_CHECK(ledc_channel_config(&ledc_channel_blue));
    ESP_ERROR_CHECK(ledc_timer_config(&ledc_timer));
}

/**
 * Set the LED color and intensity.
 * 
 * @param color 0xrrggbb, each is a %
 * @param intensity %
 * @param period %
 * @param blinkcount -1 for continuous
 * @param BlinkMode OFF, ON_OFF, ROTATE_CW, ROTATE_CCW, FADE
 * @param LLDimLevel, fade down to this level
 */
void SetLEDParms(int color, int intensity, int onperiod, int offperiod) {
//    printf("SetLEDParms: color=%d intensity=%d\n",color,intensity);
    
    //printf("SetLEDParms blinkcount=%u BlinkMode=%u onperiod=%u offperiod=%u\n", blinkcount, BlinkMode, onperiod, offperiod);

    intensity = intensity > 100 ? 100 : intensity;
    intensity = intensity < 0 ? 0 : intensity;
    intensity = (intensity * 2) / 5;
    
//    CurrentColor_g = color;

    int r = (((color >> 16) & 0xff) * intensity) / 100;
    int g = (((color >> 8) & 0xff) * intensity) / 100;
    int b = (((color) & 0xff) * intensity) / 100;
    r = r > 100 ? 100 : r;
    g = g > 100 ? 100 : g;
    b = b > 100 ? 100 : b;

    uint32_t max_duty = (1 << LEDC_TIMER_10_BIT) - 1;
    uint32_t RedDutyi = (r * (float) max_duty) / 100.0;
    uint32_t GreenDutyi = (g * (float) max_duty) / 100.0;
    uint32_t BlueDutyi = (b * (float) max_duty) / 100.0;

    // The duty cycle must be inverted because the LED outputs are common-VCC.
    RedDutyi = max_duty - RedDutyi;
    GreenDutyi = max_duty - GreenDutyi;
    BlueDutyi = max_duty - BlueDutyi;

    //printf("r=%d RedDutyi=%d max_duty=%d\n",r,RedDutyi,max_duty);

    ESP_ERROR_CHECK(ledc_set_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_1, RedDutyi));
    ESP_ERROR_CHECK(ledc_set_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_2, GreenDutyi));
    ESP_ERROR_CHECK(ledc_set_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_3, BlueDutyi));
	
    ESP_ERROR_CHECK(ledc_update_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_3));
    ESP_ERROR_CHECK(ledc_update_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_2));
    ESP_ERROR_CHECK(ledc_update_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_1));
	
    // Set other LED parms.
//    OnPeriod = onperiod;
//    OffPeriod = offperiod;
//    BlinkCount = blinkcount;
//    LEDDimLowLevel = LLDimLevel;
//    BlinkType = BlinkMode;
//    LED_SetAll(1);
}

//void Thread_LEDUpdate() {
//    int Period = 0;
//    bool LedIsOn = 1;
//    static int LedNum = 0;
//    static int LEDDimLevel = 0;
//    static bool LEDDimDirUp = 0;
//    static int LEDInc = 1;
//
//    while (1) {
//        //if (TimeSinceBootMS % 1000 == 0)
//        	//printf("LEDUpdate BlinkType=%u BlinkCount=%u OnPeriod=%u OffPeriod=%u\n", BlinkType, BlinkCount, OnPeriod, OffPeriod);
//
//        // Blink mechanism is active only if OnPeriod, OffPeriod and BlinkCount are set.
//        // BlinkCount < 0 -> blink forever
//        if(OnPeriod > 0 && OffPeriod > 0 && BlinkCount != 0) {
//            if (Period-- <= 0) {
//                if (LedIsOn)
//                    Period = OffPeriod;
//                else
//                    Period = OnPeriod;
//				
//                switch (BlinkType) {
//                    // Blink all LEDs.
//                case ON_OFF :
//                	if(LedIsOn) {
//                        BlinkCount--;
//                        // If blink is over then restore the color.
//                        if(BlinkCount == 0)
//                        	SetLEDParms(ColorBeforeBlink, 100);
//                        // If we should blink forever then continue 
//                        // blinking forever..
//                        if(BlinkCount < 0)
//                        	BlinkCount = -1;
//                        LedIsOn = 0;
//                        LED_SetAll(0);
//                        //printf("0");
//                    } else {
//                        LedIsOn = 1;
//                        LED_SetAll(1);
//                        //printf("1");
//                    }
//                    break;
//
//                    // Blink clockwise.
//                case ROTATE_CW :
//                case ROTATE_CCW :
//                		BlinkCount--;
//                    // All leds off.
//                    LED_SetAll(0);
//                    // Light the next led.
//                    gpio_set_level((gpio_num_t) LedGPIO[LedNum], 1);
//
//                    // If blink is over then restore the color.
//                    if(BlinkCount == 0) {
//                        SetLEDParms(ColorBeforeBlink, 100);
//                        LED_SetAll(1);
//                        LedNum = 0;
//                    }
//                    // If we should blink forever then continue 
//                    // blinking forever..
//                    if(BlinkCount < 0)
//                    	BlinkCount = -1;
//
//                    if (BlinkType == ROTATE_CW) {
//                        if (++LedNum > 7)
//                            LedNum = 0;
//                    }
//                    else {
//                        if (--LedNum < 0)
//                            LedNum = 7;
//                    }
//                    break;
//
//                    // Fade
//                case FADE :
//                	LEDInc = 1;
//                    if (LEDDimLevel > 20)
//                        LEDInc = 2;
//                    if (LEDDimLevel > 40)
//                        LEDInc = 4;
//                    if (LEDDimLevel > 60)
//                        LEDInc = 4;
//                    if (LEDDimLevel > 70)
//                        LEDInc = 2;
//                    if (LEDDimLevel > 90)
//                        LEDInc = 1;
//
//                    if (LEDDimDirUp) {
//                        LEDDimLevel += LEDInc;
//                        if (LEDDimLevel > 99) {
//                            LEDDimDirUp = 0;
//                        }
//                    }
//                    else {
//                        LEDDimLevel -= LEDInc;
//                        if (LEDDimLevel <= LEDDimLowLevel) {
//                            LEDDimDirUp = 1;
//                        }
//                    }
//                    SetLEDParms(CurrentColor_g, LEDDimLevel, OnPeriod, OffPeriod, -1, FADE, LEDDimLowLevel);
//                    break;
//
//                default:
//                    break;
//                }
//                ;
//            }
//
//            // If this is an off period then disable the LEDs.
//            if(!LedIsOn) {
//                LEDR_OFF;
//                LEDG_OFF;
//                LEDB_OFF;
//            }
//        } else {
//            LED_SetAll(1);
//            LedIsOn = 1;
//        }
//
//#if 0        
//        // If time to service the tricolor LED.
//        if(LedIsOn && LEDServiceDelay++ == 20) {
//            LEDServiceDelay = 0;
//
//            if (LED_R_Count0 > 0)
//                LEDR_ON;
//            if (LED_G_Count0 > 0)
//                LEDG_ON;
//            if (LED_B_Count0 > 0)
//                LEDB_ON;
//            LEDRCount = LED_R_Count0;
//            LEDGCount = LED_G_Count0;
//            LEDBCount = LED_B_Count0;
//        }
//
//        if (LEDRCount > 0)
//            LEDRCount--;
//        else
//            LEDR_OFF;
//
//        if (LEDGCount > 0)
//            LEDGCount--;
//        else
//            LEDG_OFF;
//
//        if (LEDBCount > 0)
//            LEDBCount--;
//        else
//            LEDB_OFF;
//#endif      
//        // 10ms delay
//        vTaskDelay(1);
//    }
//}

string GetConsoleString(string &s) {    
    char c;
    do {
        c = getchar();
        if (c == 0x7f || (c != 0xff && isprint(c))) {
            if (c != 0x7f)
                s.append(1, c);
            printf("%c", c);
        }
        if (c == 0x7f) 
            s.pop_back();
        vTaskDelay(pdMS_TO_TICKS(10));	
    } while (c != 10);
    printf("\n");
    
    return s;
}

void LEDColorTest() {
    string s;
    int color, intensity;
    while (1) {
        s.clear();
        GetConsoleString(s);
         
        sscanf(s.c_str(), "%x %u", &color, &intensity);
        printf("Color=0x%X, Intensity=%d\n", color, intensity);
        SetLEDParms(color, intensity, 100, 0);
    }
}
